%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Тестирование системы}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
В данном разделе производится исследование работоспособности разработанного прототипа на основе результатов его апробации на реальных проектах. В качестве тестируемой программы был выбран компилятор языка Kotlin. В качестве тестовой выборки были использованы результаты генератора случайных тестов для компилятора, а также несколько проектов на языке Kotlin, в которые искусственно вносились ошибки, приводящие к сбою компилятора. Исследованию подвергаются два основных показателя: время работы и изменение размера файла, содержащего ошибку. Редукция всех выбранных проектов производится в трех режимах: слайсинга, иерархического дельта дебаггинга и с использованием всех реализованных трансформаций.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Описание тестовых проектов}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Для апробации прототипа были выбраны следующие проекты, написанные на языке Kotlin:
\begin{itemize}
\item результаты работы генератора случайных тестов для компилятора Kotlin: 487 тестов;
\item kotlinpoet --- программный интерфейс для генерации исходных файлов на языке Kotlin; 
\item kfg --- проект для построения графа потока управления для Java байт-кода;
\item kotoed --- информационная система, автоматизирующая работу преподавателя при работе со студентами;
\item mapdb --- интерфейс между стандартными коллекциями Java и встраиваемыми системами управления базами данных.
\end{itemize}
%
В каждый из выбранных проектов (кроме результатов работы генератора случайных тестов) искусственно вносилась ошибка компилятора Kotlin. Размеры проектов и файлов с компиляторной ошибкой приведены в таблице~\ref{tab:size}. Для результатов генератора случайных тестов приведены суммарные показатели.
%
\begin{table}[]
\center
\captionsetup{skip=5pt}
\caption{\label{tab:size}Размеры тестируемых проектов и файлов с компиляторной ошибкой}
\begin{tabular}{| c | c | c |}
\hline
\bf Название & \bf N строк, тыс. & \bf Размер файла с ошибкой, Кб \\
\hline
compTests & 9 & 198.7\\
\hline
kotlinpoet & 10 & 15.2\\
\hline
kfg & 3.5 & 40.2\\
\hline
mapdb & 2 & 12.5\\
\hline
kotoed & 20 & 24\\
\hline
\end{tabular}
\end{table}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Оценка целесообразности}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Для оценки целесообразности технологии редукции программ разработанный прототип был дополнен кодом для измерения следующих показателей:
\begin{itemize}
\item времени~(t) работы прототипа в 3 режимах: полного, слайсинга и иерархического дельта дебаггинга;
\item размера~(V) результирующего файла с ошибкой.
\end{itemize}
Использование прототипа является целесообразным при выполнении следующего соотношения: $t_{full} < t_{hdd}$ и $V_{full} << V_{slicing}$

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Результаты тестирования}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Результаты тестирования проектов приведены в таблице~\ref{tab:testing}.
%
\begin{table}[]
\center
\captionsetup{skip=5pt}
\caption{\label{tab:testing}Результаты тестирования прототипа}
\begin{tabular}{| c | c | c | c | c | c | c |}
\hline
\bf \multirow{2}{*}{Проект} & \multicolumn{2}{|c|}{\bf Slice} & \multicolumn{2}{|c|}{\bf HDD} & \multicolumn{2}{|c|}{\bf Full} \\
\cline{2-7}
& время & размер & время & размер & время & размер \\
\hline
compTests & 2:30 & 65.6 & 32:23 & 33.9 & 31:55 & 21.6 \\
\hline
kotlinpoet & 2:35 & 15.1 & 80:10 & 1.8 & 16:15 & 0.3 \\
\hline
kfg & 5:29 & 38.9 & 769:19 & 1.0 & 18:48 & 0.04 \\
\hline
mapdb & 1:23 & 7.2 & 21:22 & 2.2 & 2:55 & 0.04 \\
\hline
kotoed & 9:50 & 16.4 & 971:51 & 5.5 & 61:00 & 0.8 \\
\hline
\end{tabular}
\end{table}
%
В случае с компиляторными тестами, полученными с помощью генератора случайных тестов, использование технологии является целесообразным. На рисунке~\ref{test:compare} приведены примеры результатов редукции. В приведенном файле возникает компиляторная ошибка из-за неверного вывода типов в строке \texttt{val clazz = (A)?::class.java}. Слайсинг работает более чем в 10 раз быстрее дельта дебаггинга и режима полной редукции, но его результаты заметно хуже. Иерархический дельта дебаггинг работает то же время, что и режим полной редукции, но также имеет более плохие результаты. Стоит отметить, что компиляторные тесты имеют невысокую сложность ввиду простоты генератора случайных тестов. 

\begin{figure}

\begin{subfigure}[t]{\linewidth}
\begin{lstlisting}
class A() {
    fun String.test(OK: String) {}
}

fun box(): String {
    val clazz = (A)?::class.java
    val method = clazz.getDeclaredMethod("test", String::class.java, String::class.java)
    val parameters = method.getParameters()
    if ((!method[0].isImplicit() || parameters[0].isSynthetic())) {
        return "wrong modifier on receiver parameter: ${parameters[0].modifiers}"
    }
    return parameters[1].name
}
\end{lstlisting}
\caption{Исходный тестовый пример}
\end{subfigure}

\begin{subfigure}[t]{\linewidth}
\begin{lstlisting}

fun box(): String {
	val clazz = (A)?::class.java
	val method = clazz.getDeclaredMethod("test", String::class.java, String::class.java)
	val parameters = method.getParameters()
	if ((! method[0].isImplicit() || parameters[0].isSynthetic())) {
		return "wrong modifier on receiver parameter: ${parameters[0].modifiers}"
	}
	return parameters[1].name
}
\end{lstlisting}
\caption{Результат применения алгоритма программного среза}
\end{subfigure}

\begin{subfigure}[t]{\linewidth}
\begin{lstlisting}
fun box(): String {
	val clazz = (A)?::class.java
	val method = clazz.getDeclaredMethod
	val parameters = method.getParameters
	return parameters.name
}
\end{lstlisting}
\caption{Результат применения алгоритма иерархического дельта дебаггинга}
\end{subfigure}

\begin{subfigure}[t]{\linewidth}
\begin{lstlisting}
fun box() {
	val clazz = (A)?::class.java
}
\end{lstlisting}
\caption{Результат применения разработанного прототипа}
\end{subfigure}

\caption{\label{test:compare}Пример применения алгоритмов программной редукции}
\end{figure}

Для остальных проектов метод слайсинга показал свою низкую пригодность ввиду сложности внутренних связей программных компонентов. В среднем иерархический дельта дебаггинг работает в 14 раз медленнее, чем разработанный прототип, и имеет результаты в 18 раз хуже. Такое различие по времени работы возникает из-за долгой сборки проекта при проверке каждой тестовой конфигурации. Средства профилирования показали, что если при редукции небольших компиляторных тестов процесс компиляции занимает незначительное время по сравнению с работой трансформаций, то в случае с большими проектами занимаемое сборкой время увеличивается вплоть до 90\% времени работы программы. При полной редукции благодаря реализованным трансформациям в разы сокращается размер исходной программы, которую принимает на вход иерархический дельта дебаггинг, и, следовательно, уменьшается количество проводимых проверок.

Стоит отметить, что несмотря на значительное сокращение размеров файлов с ошибкой, в некоторых случаях из них была удалена не вся информация, нерелевантная ошибке. Это произошло из-за того, что трансформации, направленные на предварительное упрощение проекта, оставляют использование компонентов из целевого файла с ошибкой. Этого можно избежать, добавив в список предварительных упрощающих трансформаций дополнительные, но из-за этого может сильно возрасти время работы прототипа.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Анализ результатов}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
На основе тестирования технологии можно сделать следующие выводы. Использование предложенной технологии является целесообразным для небольших тестовых примеров, так как время работы на них измеряется секундами. Для больших проектов, если причина и место сбоя не очевидны, можно применять технологию, но это может занять значительное время.

В проектах kotoed и kotlinpoet трансформации удаляют не всю нерелевантную к ошибке информацию, поэтому для улучшения показателей технологии программной редукции необходимо увеличивать количество и сложность трансформаций. В этом случае возрастет скорость редукции и улучшится ее результат.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Резюме}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
В данном разделе выполнена апробация разработанного прототипа, реализующего метод программной редукции, на нескольких программных проектах.
Анализ результатов свидетельствует о целесообразности применения предложенной технологии для большинства программных проектов. Некоторые примеры применения разработанного прототипа к компиляторным тестам приведены в приложении~А.
