\chapter{Тестирование системы}
В данном разделе производится исследование работоспособности разработанного прототипа на основе результатов его апробации на реальных проектах. В качестве тестируемой программы был выбран компилятор языка Kotlin. В качестве тестовой выборки были использованы результаты генератора случайных тестов для компилятора, а также несколько проектов на языке Kotlin, в которые исскуственно были внесены компиляторные ошибки. Исследованию подвергаются два основных показателя: время работы и изменение размера файла, содержащего ошибку. Редукция всех выбранных проектов производится в трех режимах: слайсинга, иерархического дельта дебаггинга и с использованием всех реализованных трансформаций.
\section{Описание тестовых проектов}
Для апробации прототипа были выбраны следующие проекты, написанные на языке Kotlin:
\begin{itemize}
\item результаты работы генератора случайных тестов для компилятора Kotlin: 487 тестов;
\item kotlinpoet --- программный интерфейс для генерации исходных файлов формата языка Kotlin; 
\item kfg --- проект для построения графа потока управления для Java байт-кода;
\item kotoed --- информационная система, автоматизирующая работу преподавателя при работе со студентами;
\item mapdb --- сочетание встроенного механизма базы данных и Java-коллекций.
\end{itemize}
В каждый из выбранных проектов искусственно вносилась ошибка компилятора Kotlin. Минимальный размер файла с ошибкой --- 0.04 Кб. Это говорит о том, что если размер результирующего файла больше минимального, то в нем осталась нерелевантная ошибке информация. Размеры проектов и файлов с компиляторной ошибкой приведены в таблице~\ref{tab:size}. Для результатов генератора случайных тестов приведены суммарные показатели.
\begin{table}[]
\center
\caption{\label{tab:size}Размеры тестируемых проектов и файлов с компиляторной ошибкой}
\begin{tabular}{| c | c | c |}
\hline
\bf Название & \bf N строк, тыс. & \bf Размер файла с ошибкой, Кб \\
\hline
compiler tests & 9 & 198.7\\
\hline
kotlinpoet & 10 & 15.2\\
\hline
kfg & 3.5 & 40.2\\
\hline
mapdb & 2 & 12.5\\
\hline
kotoed & 20 & 24\\
\hline
\end{tabular}
\end{table}

\section{Оценка целесообразности}
Для оценки целесообразности технологии аппроксимации функ­ций разработанный прототип был дополнен кодом для измерения следующих показателей:
\begin{itemize}
	\item времени(t) работы прототипа в 3 режимах: полного, слайсинга и иерархического дельта дебаггинга;
	\item размера(V) результирующего файла с ошибкой.
	
Использование прототипа является целесообразным при выполнении следующего соотношения: $t_{full} < t_{hdd}$ и $V_{full} << V_{slicing}$
\end{itemize}


\section{Результаты тестирования}
Результаты тестирования проектов приведены в таблице~\ref{tab:testing}.
\begin{table}[]
\center
\caption{\label{tab:testing}Результаты тестирования прототипа}
\begin{tabular}{| c | c | c | c | c | c | c |}
\hline
\bf \multirow{2}{*}{Проект} & \multicolumn{2}{|c|}{\bf Слайсинг} & \multicolumn{2}{|c|}{\bf Дельта дебаггинг}  & \multicolumn{2}{|c|}{\bf ReduKtor} \\
\cline{2-7}
& время & размер & время & размер & время & размер \\
\hline
compiler tests & 2:30 & 65.6 & 32:23 & 33.9 & 31:55 & 21.6 \\
\hline
kotlinpoet & 2:35 & 15.1 & 80:10 & 1.8 & 16:15 & 0.3 \\
\hline
kfg & 5:29 & 38.9 & 769:19 & 1.0 & 18:48 & 0.04 \\
\hline
mapdb & 1:23 & 7.2 & 21:22 & 2.2 & 2:55 & 0.04 \\
\hline
kotoed & 9:50 & 16.4 & 971:51 & 5.5 & 61:00 & 0.8 \\
\hline
\end{tabular}
\end{table}
В случае с компиляторными тестами, полученными с помощью генератора случайных тестов, использование технологии является оправданным. На рисунке~\ref{test:compare} приведены примеры результатов редукции. В приведенном файле возникает компиляторная ошибка из-за неверного вывода типов. Слайсинг работает более чем в 10 раз быстрее дельта дебаггинга и полного режима, но его результаты заметно хуже. Иерархический дельта дебаггинг работает то же время, что и полный режим, но также имеет более плохие результаты. Для приведенного примера полный режим выигрывает из-за трансформации, приводящей тип возвращаемого значения функции к Unit. Стоит отметить, что компиляторные тесты имеют невысокую сложность ввиду простоты генератора случайных тестов.
\begin{figure}
\center{
\begin{lstlisting}
class A() {
    fun String.test(OK: String) {}
}

fun box(): String {
    val clazz = (A)?::class.java
    val method = clazz.getDeclaredMethod("test", String::class.java, String::class.java)
    val parameters = method.getParameters()
    if ((!method[0].isImplicit() || parameters[0].isSynthetic())) {
        return "wrong modifier on receiver parameter: ${parameters[0].modifiers}"
    }
    return parameters[1].name
}
\end{lstlisting}
a)}
\center{
\begin{lstlisting}

fun box(): String {
	val clazz = (A)?::class.java
	val method = clazz.getDeclaredMethod("test", String::class.java, String::class.java)
	val parameters = method.getParameters()
	if ((! method[0].isImplicit() || parameters[0].isSynthetic())) {
		return "wrong modifier on receiver parameter: ${parameters[0].modifiers}"
	}
	return parameters[1].name
}
\end{lstlisting}
б)}

\center{
\begin{lstlisting}
fun box(): String {
	val clazz = (A)?::class.java
	val method = clazz.getDeclaredMethod
	val parameters = method.getParameters
	return parameters.name
}
\end{lstlisting}
в)}

\center{
\begin{lstlisting}
fun box() {
	val clazz = (A)?::class.java
}
\end{lstlisting}
г)}
\caption{\label{test:compare}Пример применения алгоритмов программной редукции. а)~Исходный тестовый пример б)~Результат применения алгоритма программного среза в)~Результат применения алгоритма иерархического дельта дебаггинга г)~Результат применения разработанного прототипа}
\end{figure}

Для остальных проектов метод слайсинга показал свою низкую пригодность ввиду сложности внутренних связей программных компонентов. В среднем иерархический дельта дебаггинг работает в 14 раз медленнее, чем разработанный прототип и имеет результаты в 18 раз хуже. Такое различие по времени работы возникает из-за долгой сборки проекта при проверке каждой тестовой конфигурации. Средства профилирования показали, что если при редукции небольших компиляторных тестов процесс компиляции занимает незначительное время по сравнению с работой трансформаций, то в случае с большими проектами занимаемое сборкой время увеличивается вплоть до 90\% времени работы программы. При полной редукции благодаря реализованным трансформациям в разы сокращается размер исходной программы, которую принимает на вход иерархический дельта дебаггинг, и, следовательно, уменьшается количество проводимых проверок. 

Стоит отметить, что несмотря на значительное сокращение размеров файлов с ошибкой, в некоторых случаях из них была удалена не вся информация, нерелевантная ошибке. Это произошло из-за того, что трансформации, направленные предварительное упрощение проекта, оставляют использование переменных из целевого файла с ошибкой. Этого можно избежать, добавив в список предварительных упрощающих проходов дополнительные трансформации, но из-за этого может сильно возрасти время работы прототипа.


\section{Анализ результатов}
На основе тестирования технологии можно сделать следующие выводы. Использование предложенной технологии является целесообразным для небольших тестовых примеров, так как время работы на них измеряется секундами. Для больших проектов, если причина и место сбоя не очевидны, можно применять технологию, в это время сосредоточившись на других проблемах.

В проектах kotoed и kotlinpoet трансформации удаляют не всю нерелевантную к ошибке информацию, поэтом для улучшения показателей технологии программной редукции необходимо увеличивать количество и сложность трансформаций. В этом случае возрастет скорость редукции и улучшится ее результат.

\section{Резюме}
В данном разделе выполнена апробация разработанного прототипа, реализующего метод программной редукции на нескольких программных проектах.
Анализ результатов свидетельствует о целесообразности применения предложенной технологии для большинства программных проектов.