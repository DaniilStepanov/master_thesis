%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Описание методов локализации ошибок}
В данном разделе производится обзор методов автоматической редукции. Для каждого подхода приводятся его преимущества и недостатки, а также область применения.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Дельта дебаггинг}
Как было написано ранее, локализация ошибок всегда производилась вручную, но в 2002 году ученые
А. Зеллер и Р. Хильдебрандт предложили автоматизировать данный процесс для экономии человеческих ресурсов~\cite{zeller2002simplifying}. Подход, который они изобрели называется дельта дебаггинг. Алгоритм представляет собой вариацию двоичного поиска для удаления частей тестового примера t для создания нового примера $t_{min}$, удовлетворяющего двум условиям:
\begin{itemize}
\item $t_{min}$ приводит к отказу программы;
\item если удалить какую-либо часть из $t_{min}$ получается тестовый пример, не приводящий к сбою.
\end{itemize}
Опишем алгоритм дельта дебаггинга(ddmin). Пусть даны $test$ и $c_x$, такие что $test(c_x)$ приводит к сбою программы. Необходимо найти $c'_x = ddmin(c_x)$, такое что $c'_x \subseteq c_x, test(c'_x) = fail$. Чтобы найти минимальную тестовую выборку, невозможно просто пытаться удалить каждый элемент по очереди. Поэтому в алгоритме ипользуется бинарный поиск: поделим исходную тестовую выборку на 2 равные части: $\Delta_1$ и $\Delta_2$ и попытаемся запустить тест на каждой из них. Возможные варианты исхода:
\begin{itemize}
\item происходит сбой на подвыборке $\Delta_1$;
\item на подвыборке $\Delta_1$ программа отрабатывает корректно, но на подвыборке $\Delta_2$ происходит сбой;
\item ни одна из подвыборок не приводит к сбою.
\end{itemize}
В первых двух случаях мы можем продолжить искать минимальную тестовую выборку в подвыборке, которая привела к сбою. Пример показан в таблице~\ref{tab:ddminex}. На 5-ом шаге мы находим минимальную тестовую выборку, приводящую к сбою программы.
\begin{table}[]
\center
\caption{\label{tab:ddminex}Пример работы алгоритма дельта дебаггинга}
\begin{tabular}{| c | *{4}{c} | c |}
\hline
\bf Шаг & \multicolumn{4}{|c|}{\bf Выборка} & {\bf Результат}\\
\hline
1 &  1 & 2 & 3 & 4 & fail \\
\hline
2 &  1 & 2 & . & . & ok \\
\hline
3 &  . & . & 3 & 4 & fail \\
\hline
4 &  . & . & 3 & . & ok \\
\hline
5 &  . & . & . & 4 & fail \\
\hline
\end{tabular}
\end{table}

Теперь рассмотрим вариант, когда ни одна из подвыборок не приводит к сбою. Логично, мы должны разделить выборку на другие подвыборки. В алгоритме дельта дебаггинга применяется разбиение выборки на большее число подмножеств, а также ее дополнение: $\nabla_i = c_x - \Delta_i$. Пусть мы делим тестовую выборку $c_x$ на n частей. Поэтому мы должны протестировать программу на каждой подвыборке $\Delta_0,...,\Delta_n$ и на каждом дополнении $\nabla_0,...,\nabla_n$. Возможны следующие варианты
\begin{itemize}
\item происходит сбой на подвыборке $\Delta_i$ --- принимаем $\Delta_i$ как новую тестовую выборку и продолжаем работать с ней, начиная с n = 2 ;
\item происходит сбой на подвыборке $\nabla_i$ --- принимаем $\nabla_i$ как новую тестовую выборку и продолжаем работать с ней, начиная с n = n - 1. Параметр принимает такую величину для избегания лишней работы, так как большое количество подвыборок с меньшей грануллированностью уже были протестированы;
\item если никакая из подвыборок не приводит к сбою, увеличиваем грануллированность: $n = 2n$. Это делается только тогда, когда $2n > |c_x|$, в противном случае алгоритм заканчивает свою работу.
\end{itemize}

Обобщение алгоритма приведено на рисунке~\ref{ddminalg}
\begin{figure}
	$ddmin(c_x) = ddmin_2(c_x, 2)$ где \\
\[ ddmin_2(c'_x, n) =
  \begin{cases}
    ddmin_2(\Delta_i, 2)       & \quad \text{if } test(\Delta_i) = fail\\
    ddmin_2(\nabla_i, max(n - 1, 2))       & \quad \text{if } test(\nabla_i) = fail\\
    ddmin_2(c'_x, min(|c'_x|, 2n))       & \quad \text{if } n < |c'_x|\\
    c'_x
  \end{cases}
\]
\\
где $\nabla_i = c'_x - \Delta_i, c'_x = \Delta_1 \cup \Delta_2 \cup ... \cup \Delta_n$, все $\Delta_i$ попарно не пересекаются
\caption{Алгоритм дельта дебаггинга}
\label{ddminalg}
\end{figure}
Приведем пример работы алгоритма дельта дебаггинга. В качестве тестируемого объекта будет использоваться систему, в которой происходит сбой, если подать на вход два одинаковых числа подряд. Работа алгоритма показана в таблице~\ref{tab:ddminex2}
\begin{table}[]
\center
\caption{\label{tab:ddminex2}Пример работы алгоритма дельта дебаггинга}
\begin{tabular}{| c | *{8}{c} | c | c |}
\hline
\bf Шаг & \multicolumn{8}{|c|}{\bf Выборка} & {\bf Результат} & {\bf Комментарий}\\
\hline
1 &  8 & 3 & 1 & 5 & . & . & . & .  & ok & \\
\hline
2 &  . & . & . & . & 7 & 4 & 4 & 1 & fail & Новая подвыборка\\
\hline
3 &  . & . & . & . & 7 & 4 & . & . & ok & \\
\hline
4 &  . & . & . & . & . & . & 4 & 1 & ok & $n = 2n$\\
\hline
5 &  . & . & . & . & 7 & . & . & . & ok & \\
\hline
6 &  . & . & . & . & . & 4 & . & . & ok &\\
\hline
7 &  . & . & . & . & . & . & 4 & . & ok &\\
\hline
8 &  . & . & . & . & . & . & . & 1 & ok &Тестируем дополнения\\
\hline
9 &  . & . & . & . & . & 4 & 4 & 1 & fail &Новая подвыборка\\
\hline
10 &  . & . & . & . & . & 4 & 4 & . & fail &Новая подвыборка\\
\hline
11 &  . & . & . & . & . & 4 & . & . & ok &\\
\hline
12 &  . & . & . & . & . & . & 4 & . & ok & Конец\\
\hline
\end{tabular}
\end{table}
Главным недостатком дельта дебаггинга является то, что он не учитывает структурированность ввода и поэтому не подходит для редукции сложных данных, будь то АСД или текст программы.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Дельта дебаггинг с использованием topformflat}
Ученые МакПик и Уилкерсон реализовали алгоритм дельта дебаггинга~\cite{delta} для языка C, в котором учли возможную структурированность входного теста. Для этого они использовали утилиту, которая называется topformflat.

Самый очевидный пример структурированного входного теста --- текст программы. Предпроложим, мы тестируем компилятор и у нас происходит сбой на каком-то тестовом примере и мы хотим его минимизировать. Для этого представим исходный код как множество строк, и, следовательно, алгоритм дельта дебаггинга будет работать со строками. topformflat --- это простая утилита для обработки вложенности в  языке программирования C. 

Глубина вложенности строки исходного кода --- количество блоков, в которых находится эта строка. Для понимания на рисунке~\ref{img:topformflatex} приведен пример кода и глубина вложенности каждой строки.

\begin{figure}
\center
\caption{Пример кода на языке С с указанием вложенности каждой строки}
\begin{tabular}{ |c|c|c| } 
\hline
\bf Код & \bf Глубина  \\
\hline
\multirow{7}{15em}{int gcd (int a, int b) \{ \\
\ \ \ \ if (b == 0) \{ \\
\ \ \ \ \ \ \ \ return a; \\
\ \ \ \ \} else \{ \\
\ \ \ \ \ \ \ \ return gcd (b, a \% b); \\
\ \ \ \ \} \\
\}
} & 0\\ 
& 1 \\ 
& 2  \\ 
& 1 \\ 
& 2  \\ 
& 1 \\ 
& 0 \\
\hline
\end{tabular}
\label{img:topformflatex}
\end{figure}
На вход утилите подается желаемая глубина и текст программы. На выходе получается программа с глубиной вложенностей не более заданной. Это происходит путем удаления переводов строк и конкатенации строки с глубиной более заданной с предыдущей строкой. На рисунке~\ref{} приведен пример применения утилиты с заданной глубиной 1.
\begin{figure}
\center
\caption{Пример кода на языке С с указанием вложенности каждой строки}
\begin{tabular}{ |c|c|c| } 
\hline
\bf Код & \bf Глубина  \\
\hline
\multirow{7}{15em}{int gcd (int a, int b) \{ \\
\ \ \ \ if (b == 0) \{ \\
\ \ \ \ \ \ \ \ return a; \\
\ \ \ \ \} else \{ \\
\ \ \ \ \ \ \ \ return gcd (b, a \% b); \\
\ \ \ \ \} \\
\}
} & 0\\ 
& 1 \\ 
& 2  \\ 
& 1 \\ 
& 2  \\ 
& 1 \\ 
& 0 \\
\hline
\end{tabular}
\label{img:topformflatex}
\end{figure}
fopformflat легко интегрируется с алгоритмом дельта дебаггинга. Суть состоит в том, что нужно применять алгоритм, постепенно увеличивая глубину вложенности, начиная с нулевой. Несмотря на то что данный алгоритм позволяет существенно снизить количество синтаксически некорректных тестов, главный его недостаток заключается в том, что глубина вложенности расчитывается по фигурным скобкам, поэтому она применима к ограниченному количеству языков программирования. Также недостатком данного метода является то, что он работает на уровне строк, поэтому меньше невозможно удалить то, что меньше строки.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Иерархический дельта дебаггинг}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Программный слайсинг}
Статический и динамический 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Related works}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Резюме}
