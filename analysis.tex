%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Описание методов локализации ошибок}
В данном разделе производится обзор методов автоматической редукции. Для каждого подхода приводятся его преимущества и недостатки, а также область применения. Рассматриваются существующие в настоящее время системы автоматической редукции программ.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Дельта дебаггинг}
Первые шаги в области автоматической локализации ошибок сделали А.Зеллер и Р.Хильдебрандт в 2002 году. Они предложили автоматизировать данный процесс для экономии человеческих ресурсов~\cite{zeller2002simplifying}. Подход, который они изобрели для этого называется дельта дебаггинг. Алгоритм представляет собой вариацию двоичного поиска для удаления частей тестового примера $t$ для создания нового примера $t_{min}$, удовлетворяющего двум условиям:
\begin{itemize}
\item $t_{min}$ также приводит к отказу программы;
\item если удалить какую-либо часть из $t_{min}$ получается тестовый пример, не приводящий к сбою.
\end{itemize}
Опишем алгоритм дельта дебаггинга (ddmin). Пусть даны $test$ и $c_x$, такие что $test(c_x)$ приводит к сбою программы. Необходимо найти $c'_x = ddmin(c_x)$, такое что $c'_x \subseteq c_x, test(c'_x) = fail$. Чтобы найти минимальную тестовую выборку, невозможно просто пытаться удалить каждый элемент по очереди. Поэтому в алгоритме ипользуется бинарный поиск: исходная тестовая выборка делится на 2 равные части: $\Delta_1$ и $\Delta_2$ и производится запуск теста на каждой из них. Возможные варианты исхода:
\begin{itemize}
\item происходит сбой на подвыборке $\Delta_1$;
\item на подвыборке $\Delta_1$ программа отрабатывает корректно, но на подвыборке $\Delta_2$ происходит сбой;
\item ни одна из подвыборок не приводит к сбою.
\end{itemize}
В первых двух случаях мы можем продолжить искать минимальную тестовую выборку в подвыборке, которая привела к сбою. Предположим, что к программному сбою приводит последний элемент тестовой выборки. Процесс редукции для этого случая показан в таблице~\ref{tab:ddminex}. Минимальную тестовая выборка, приводящаю к сбою программы, найдена на 5 шаге.
\begin{table}[]
\center
\caption{\label{tab:ddminex}Пример работы алгоритма дельта дебаггинга}
\begin{tabular}{| c | *{4}{c} | c |}
\hline
\bf Шаг & \multicolumn{4}{|c|}{\bf Выборка} & {\bf Результат}\\
\hline
1 &  1 & 2 & 3 & 4 & fail \\
\hline
2 &  1 & 2 & . & . & ok \\
\hline
3 &  . & . & 3 & 4 & fail \\
\hline
4 &  . & . & 3 & . & ok \\
\hline
5 &  . & . & . & 4 & fail \\
\hline
\end{tabular}
\end{table}

Теперь рассмотрим вариант, когда ни одна из подвыборок не приводит к сбою. Логично, мы должны разделить выборку на другие подвыборки. В алгоритме дельта дебаггинга применяется разбиение выборки на большее число подмножеств $\Delta_i$, также формируется выборка без данного подмножества: $\nabla_i = c_x - \Delta_i$. Пусть мы делим тестовую выборку $c_x$ на n частей. Параметр n называется гранулированностью выборки. Далее необходимо протестировать программу на подвыборках $\Delta_0,...,\Delta_n$, а затем на $\nabla_0,...,\nabla_n$. Возможны следующие варианты:
\begin{itemize}
\item происходит сбой на подвыборке $\Delta_i$ --- принимаем $\Delta_i$ как новую тестовую выборку и продолжаем работать с ней, начиная с n = 2;
\item происходит сбой на подвыборке $\nabla_i$ --- принимаем $\nabla_i$ как новую тестовую выборку и продолжаем работать с ней, начиная с n = n - 1. Параметр принимает такую величину для избежания лишней работы, так как большое количество подвыборок с меньшей гранулированностью уже были протестированы;
\item если никакая из подвыборок не приводит к сбою, увеличиваем гранулированность: $n = 2n$. Это производится тогда, когда $2n > |c_x|$, в противном случае алгоритм заканчивает свою работу.
\end{itemize}

Обобщение алгоритма приведено на рисунке~\ref{ddminalg}
\begin{figure}
	$ddmin(c_x) = ddmin_2(c_x, 2)$ где \\
\[ ddmin_2(c'_x, n) =
  \begin{cases}
    ddmin_2(\Delta_i, 2)       & \quad \text{if } test(\Delta_i) = fail\\
    ddmin_2(\nabla_i, max(n - 1, 2))       & \quad \text{if } test(\nabla_i) = fail\\
    ddmin_2(c'_x, min(|c'_x|, 2n))       & \quad \text{if } n < |c'_x|\\
    c'_x
  \end{cases}
\]
\\
где $\nabla_i = c'_x - \Delta_i, c'_x = \Delta_1 \cup \Delta_2 \cup ... \cup \Delta_n$, все $\Delta_i$ попарно не пересекаются
\caption{Алгоритм дельта дебаггинга}
\label{ddminalg}
\end{figure}
Приведем пример работы алгоритма дельта дебаггинга. В качестве тестируемого объекта будет использоваться система, в которой происходит сбой, если подать на вход подряд два одинаковых числа. Работа алгоритма показана в таблице~\ref{tab:ddminex2}.
\begin{table}[]
\center
\caption{\label{tab:ddminex2}Пример работы алгоритма дельта дебаггинга}
\begin{tabular}{| c | *{8}{c} | c | c |}
\hline
\bf Шаг & \multicolumn{8}{|c|}{\bf Выборка} & {\bf Результат} & {\bf Комментарий}\\
\hline
1 &  8 & 3 & 1 & 5 & 7 & 4 & 4 & 1  & fail & \\
\hline
1 &  8 & 3 & 1 & 5 & . & . & . & .  & ok & \\
\hline
2 &  . & . & . & . & 7 & 4 & 4 & 1 & fail & Новая подвыборка\\
\hline
3 &  . & . & . & . & 7 & 4 & . & . & ok & \\
\hline
4 &  . & . & . & . & . & . & 4 & 1 & ok & $n = 2n$\\
\hline
5 &  . & . & . & . & 7 & . & . & . & ok & \\
\hline
6 &  . & . & . & . & . & 4 & . & . & ok &\\
\hline
7 &  . & . & . & . & . & . & 4 & . & ok &\\
\hline
8 &  . & . & . & . & . & . & . & 1 & ok &Тестируем $\nabla_i$\\
\hline
9 &  . & . & . & . & . & 4 & 4 & 1 & fail &Новая подвыборка\\
\hline
10 &  . & . & . & . & . & 4 & 4 & . & fail &Новая подвыборка\\
\hline
11 &  . & . & . & . & . & 4 & . & . & ok &\\
\hline
12 &  . & . & . & . & . & . & 4 & . & ok & Конец\\
\hline
\end{tabular}
\end{table}
Главным недостатком дельта дебаггинга является то, что он не учитывает структурированность ввода и поэтому не подходит для редукции сложных данных, будь то АСД или текст программы.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Дельта дебаггинг с использованием topformflat}
Ученые МакПик и Уилкерсон реализовали алгоритм дельта дебаггинга~\cite{delta} для языка C, в котором учли возможную структурированность входного теста. Для этого они использовали утилиту, которая называется topformflat.

Самый очевидный пример структурированного входного теста --- текст программы. Предпроложим, мы тестируем компилятор и у нас происходит сбой на каком-то тестовом примере и мы хотим его минимизировать. Для этого представим исходный код как множество строк, и, следовательно, алгоритм дельта дебаггинга будет работать на уровне строк. Для учета структурированности используется topformflat --- простая утилита для обработки вложенности в языке программирования C. 

Глубина вложенности строки исходного кода --- количество блоков, в которых находится эта строка. На рисунке~\ref{img:topformflatex} приведен пример кода и глубина вложенности каждой строки.

\begin{figure}
\center
\caption{Пример кода на языке С с указанием вложенности каждой строки}
\begin{tabular}{ |c|c|c| } 
\hline
\bf Код & \bf Глубина  \\
\hline
\multirow{7}{15em}{int gcd (int a, int b) \{ \\
\ \ \ \ if (b == 0) \{ \\
\ \ \ \ \ \ \ \ return a; \\
\ \ \ \ \} else \{ \\
\ \ \ \ \ \ \ \ return gcd (b, a \% b); \\
\ \ \ \ \} \\
\}
} & 0\\ 
& 1 \\ 
& 2  \\ 
& 1 \\ 
& 2  \\ 
& 1 \\ 
& 0 \\
\hline
\end{tabular}
\label{img:topformflatex}
\end{figure}
На вход утилите подается желаемая глубина и текст программы. На выходе получается программа с глубиной вложенностей не больше заданной. Это происходит путем удаления переводов строк и конкатенации строки с глубиной более заданной с предыдущей строкой. На рисунке~\ref{img:topformflatex1} приведен пример применения утилиты с заданной глубиной 1.
\begin{figure}
\center
\caption{Пример кода на языке С с указанием вложенности каждой строки}
\begin{tabular}{ |c|c|c| } 
\hline
\bf Код & \bf Глубина  \\
\hline
\multirow{4}{15em}{int gcd (int a, int b) \{ \\
\ \ \ \ if (b == 0) \{ return a; \} \\
\ \ \ \ else \{ return gcd (b, a \% b);\} \\
\}
} & 0\\ 
& 1 \\ 
& 1  \\ 
& 0 \\
\hline
\end{tabular}
\label{img:topformflatex1}
\end{figure}
topformflat легко интегрируется с алгоритмом дельта дебаггинга. Суть состоит в том, что нужно применять алгоритм, постепенно увеличивая глубину вложенности, начиная с нулевой. Несмотря на то что данный алгоритм позволяет существенно снизить количество синтаксически некорректных тестов, главный его недостаток заключается в том, что глубина вложенности расчитывается по фигурным скобкам, поэтому она применима к ограниченному количеству языков программирования. Также недостатком данного метода является то, что он работает на уровне строк, поэтому удалять из программы можно только строки, чего недостаточно для качественной редукции.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Иерархический дельта дебаггинг}
В 2006 году ученые Мишерги и Су решили проблему применения алгоритма дельта дебаггинга к иерархическим структурам данных~\cite{misherghi2006hdd}, применяя данный алгоритм к дереву разбора, представляющему входной тест. В предложенном методе дельта дебаггинг применяется поочередно к каждому уровню синтаксического дерева. Алгоритм иерархического дельта дебаггинга представлен на рисунке~\ref{alg:hdd}. 

На второй строке алгоритма задается уровень, с которого начинается обработка дерева. На следующей строке собираются все узлы дерева данной глубины, для этого используется стандартный обход в ширину. Если на текущем уровне дерева есть узлы, то для них применяется процедура дельта дебаггинга, которая находит минимальную конфигурацию узлов данного уровня, на котором происходит сбой программы. Далее из дерева удаляются все ненужные узлы и производится переход на следующий уровень. 

Приведем пример работы алгоритма. Допустим, производится тестирование компилятора и происходит сбой при компиляции клда, приведенного на рисунке \ref{ex1:hdd} из-за декремента оператора \texttt{b} в блоке \texttt{while}. На рисунке~\ref{ex:hdd}b показан результат применения алгоритма иерархического дельта дебаггинга к синтаксическому дереву, приведенному на рисунке~\ref{ex:hdd}a. Минимизированное дерево соотсветствует следующему коду:
\begin{figure}
\begin{lstlisting}
fun f() {
    var b = 0
    while (b != 0) {
        --b
    }
}
\end{lstlisting}
\end{figure}


\begin{figure}
\begin{lstlisting}
fun f() {
    val a = 1
    var b = 0
    if (a != 0) {
        b += 1
    } else {
        b += 2
    }
    while (b != 0) {
        --b
    }
}
\end{lstlisting}
\caption{\label{ex1:hdd}Код, приводящий к ошибке компилятора}
\end{figure}


\begin{figure}[h]
\center{\includegraphics[width=0.99\linewidth]{fig/hddexample} a)}
\center{\includegraphics[height=0.3\textheight]{fig/hddexample2} \\ b)}
\caption{Пример работы алгоритма иерархического дельта дебаггинга a) Синтаксическое дерево до редукции b) Результат применения алгоритма}
\label{ex:hdd}
\end{figure}

Преимуществом данного алгоритма является его применимость к любому виду входных тестовых примеров и лучшие по сравнению с классическим дельта дебаггингом результаты работы. Недостатком является необходимость построения дерева и время работы.
\begin{figure}[h]
\begin{algorithmic}[1]
\STATE $HDD(tree)$
\STATE $level \Leftarrow 0$
\STATE $nodes \Leftarrow getNodes(tree, level)$
\WHILE{$nodes != 0$} 
	\STATE $min \Leftarrow DDMIN(nodes)$
	\STATE $removeNodes(tree, level, minconfig)$
	\STATE $level \Leftarrow level + 1$
	\STATE $nodes \Leftarrow getNodes(tree, level)$
\ENDWHILE
\end{algorithmic}
\caption{Алгоритм иерархического дельта дебаггинга}
\label{alg:hdd}
\end{figure}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Программные срезы}
М. Вайзером в работе~\cite{weiser1981program} вводится понятие slicing --- выделение из программы ее определенных частей, называемыми программными срезами. Срез программы определяется по критерию, который как правило задается парой точка программы и множество переменных. Когда критерий задан, срез программы должен содержать те элементы программы, которые прямым или косвенным образом влияют на переменные из критерия. Задача вычисления срезов получила название в русскоязычной литературе получила слайсинг~\cite{2002slicing}. На рисунке~\ref{ex:slice} приведен пример программы и ее среза относительно критерия \(12, \{TOTAL\}\) из работы~\cite{weiser1981program}
\begin{figure}[]
\begin{lstlisting}
BEGIN
READ(X,Y)
TOTAL := 0.0
SUM := 0.0
IF X <= 1
	THEN SUM := Y
	ELSE BEGIN
		READ(Z)
		TOTAL := X*Y
		END
WRITE(TOTAL, SUM)
END.
\end{lstlisting}
Срез по критерию <12, {TOTAL}>, где первый элемент критерия --- точка программы, а второй --- переменная
\begin{lstlisting}
BEGIN
READ(X,Y)
TOTAL := 0.0
IF X <= 1
	THEN 
	ELSE TOTAL := X*Y
END.
\end{lstlisting}
\caption{Пример программного среза}
\label{ex:slice}
\end{figure}
В подходе Вайзера срезы вычисляются в соотстветствии с имеющимися зависимостями по данным и по управлению. Для вычисления срезов используется только статическая информация. Альтернативный подход был предложен учеными Оттенштейнами~\cite{ottenstein1984program}. Они предложили переформулировать проблему статического среза в терминах проблемы достижимости в графе зависимости по данным (ГПЗ)~\cite{ferrante1987program}. ГПЗ представляет собой ориентированный граф с вершинами, соответствующими операторам и выражениям программы, и дугами, соответствующими зависимостям по управлению и по данным между ними. Критерий среза идентифицируется вершиной в данном графе, а срез соответствует всем вершинам графа, из которых достижима интересующая нас вершина. Еще один подход был предложен Бергеретти и Карре~\cite{bergeretti1985information}, которые определяют срезы в терминах отношений информационного потока, извлекаемых из программы с помощью синтаксического анализа программы. 

Все срезы, упоминавшиеся ранее, вычисляются при помощи объединения операторов и предикатов (управляющих выражений) при обратном обходе (т.е. при движении по дугам графа против их направления) управляющего графа или графа зависимостей по данным, начиная с той точки, где находится критерий среза. Поэтому полученные таким образом срезы называются обратными статическими срезами.   Бергеретти и Карре~\cite{bergeretti1985information} впервые определили понятие прямых статических срезов. Прямой срез состоит из всех операторов и предикатов, зависимых от критерия среза; оператор «зависит» от критерия среза, если значения, вычисляемые оператором, зависят от значений, вычисляемых критерием, либо если значения, вычисляемые критерием, определяют, будет ли исполняться рассматриваемый оператор или нет. 

В случае динамического среза программ к рассмотрению принимаются только те зависимости между элементами программы, которые возникают при данном конкретном ее исполнении. Критерий динамического среза определяет входные данные и отсекает неподходящие вхождения операторов в истории исполнения; обычно этот критерий задается тройкой (входные данные, вхождение оператора, переменная). Другими словами, основное различие между статическим и динамическим подходами к построению срезов программ состоит в том, что динамический срез предполагает фиксированные входные данные, тогда как статический срез не делает предположений о входных данных программы. На рисунке~\ref{ex:dynslice} приведен пример программы и ее динамического среза относительно критерия <2, 7, {TOTAL}>
\begin{figure}[]
\begin{lstlisting}
BEGIN
READ(X)
TOTAL := 0.0
IF X <= 1
	THEN TOTAL := X + 1
	ELSE TOTAL := TOTAL + X
WRITE(TOTAL)
END.
\end{lstlisting}
Срез по критерию <2, 7, {TOTAL}>, где первый элемент критерия --- точка программы, а второй --- переменная
\begin{lstlisting}
BEGIN
READ(X)
TOTAL := 0.0
IF X <= 1
	THEN
	ELSE TOTAL := TOTAL + X
WRITE(TOTAL)
END.
\end{lstlisting}
\caption{Пример динамического программного среза}
\label{ex:dynslice}
\end{figure}

Преимуществами слайсинга являются точность и скорость работы. Главным недостатком является сложность реализации, поскольку для современных языков программирования, использующих динамическую память, необходимо реализовать анализ указателей~\cite{deutsch1994interprocedural}, то есть может ли один указатель неявно изменить значение ячейки памяти, на которую указывает другой указатель. В дополнение к этому необходимо учитывать все уровни абстракции: функции, классы, пакеты. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Related works}
Сущесвует несколько инструментов для редукции программного кода. Первый из них называется Picireny и описывается в статье~\cite{hodovan2017tree}. Picireny --- реализация алгоритма иерархического дельта дебаггинга. Данный фреймворк является универсальным, принимает на вход грамматику, с помощью ANTLR~\cite{parr2013definitive} строит целевое дерево разбора, над которым и производятся все манипуляции. Преимущества и недостатки у фреймворка те же, что и у алгоритма иерархического дельта дебаггинга, которые были перечислены ранее. 

В настоящее время существует несколько инструментов программного среза для языков программирования Java и C: JSlice~\cite{WR:04}, Indus~\cite{jayaraman2005kaveri}, JavaBST~\cite{abdallah2017javabst} и CodeSurfer~\cite{anderson2004codesurfer}. Данные инструменты реализуют различные по сложности и качеству работы алгоритмы слайсинга. Стоит отметить, что методы программного среза и дельта дебаггинга не обязательно должны быть конкурирующими --- их можно использовать вместе, например, перед дельта дебаггингом запустить быстрый статический слайсинг, который значительно упростит тестовый пример.


Наиболее совершенным в данный момент инструментом редукции можно смело назвать creduce~\cite{regehr2012test}. Creduce разработан для редукции тестовых примеров для компилятора языков (С/C++). Основное применение данного инструмента --- редукция результатов генератора случайных тестов Csmith~\cite{yang2011finding}, так как случайно сгенерированные тесты содержат огромное количество нерелевантной информации. Creduce является гибридным средством, состоящим из следующего набора трансформаций:
\begin{itemize}
	\item дельта-дебаггинг с использованием topformflat;
	\item более тридцати трансформаций над исходным кодом, например: встраивание небольших функций, удаление неиспользуемых функций и переменных, удаление неиспользуемого аргумента из функции и т.д.;
	\item форматирование получившегося кода.
\end{itemize}
Результаты тестирования данного средства показали его успешность при решении поставленных задач. Недостатком Creduce является то, что он работает только с языками программирования (C/C++).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Резюме}
В данном разделе выполнено рассмотрение предметной области локализации программных ошибок Рассмотрены существу­ющие методики редукции и инструменты, реализующие описанные методики. Подавляющее большинство инструментов предназначены для популярных языков программирования C и Java, поэтому задача для создания инструмента редукции для других языков программирования считается актуальной.