\chapter{Разработка прототипа}
В данном разделе описываются значимые детали реализации прототипа метода редукции програм на языке Kotlin. Прототип также разрабатывался на языке программирования Kotlin. Основное применение прототипа --- редукция ошибок компилятора языка Kotlin. Источником информации в этом разделе является исходный код прототипа, частично представленный в приложении.
\section{Архитекура прототипа}
Разрабатываемый прототип основывается на предложенной технологии. Общая структура пакетов представлена на рисунке~\ref{packages}.

\section{Реализация инструмента для построения PSI}
В пакете \texttt{parser} содержится код, предназначенный для построения СД из исходного кода языка программирования Kotlin. Путь к исходному коду задается через программный аргумент \texttt{--path}. Построение производится путем использования инструментария компилятора Kotlin. Для каждого файла с исходным кодом строится свой СД. Стоит отметить, что для прохода по СД и его редактированию также используется функциональность компилятора Kotlin.

Как было написано ранее, язык программирования Kotlin полностью совместим с языком Java. В качестве дополнительной функциональности было реализовано получение СД для кода на языке программирования Java, так как большое количество программ являются мультиплатформенными, то есть имеющими код как на языке Kotlin, так и на языке Java. Поэтому для обработки таких проектов будет необходимо редуцировать и код на языке Java. 

\section{Реализация редуцирующих проходов}
В пакете \texttt{passes} содержатся все редуцирующие проходы. Проходом называется реализация конкретной трансформации или ее части. Проход принимает на вход какое-либо представление кода и всю необходимую информацию и трнасформирует его. То есть на выходе они дают программу, которая приводит к той же ошибке, что и представление, поданное на вход, но только имеет меньший размер. Все реализованные алгоритмы соотвествуют описанным в предыдущей главе. Ниже приведены особенности реализации некоторых из них.

Класс \texttt{ParallelHierarchialDeltaDebugging} реализует параллельный дельта дебаггинг СД путем запуска в отдельных потоках обработки различных уровней дерева. Эксперименты показали, что данная доработка не ускоряет работу метода из-за того что, при удалении более высокоуровнего объекта происходит исключение из обработки большого количества низкоуровневых. И почти всегда количество обрабатываемых дополнительно низкоуровневых элементов настолько велико, что оно перекрывает преимущества параллельной обработки. Путь решения данной проблемы --- при удалении какого-либо элемента сообщать всем нижним уровням и исключать из рассмотрения всех детей удаленного элемента. Но при этом редукцию на этих уровнях нужно будет запускать заново. Из-за этого распараллеливание дельта дебаггинга на уровне уровней дерева разбора можно считать неактуальным. 

Класс \texttt{PeepholePasses} реализует все алгоритмы обработки текстового представления программы. Шаблоны, описанные в предыдущей главе, задаются при помощи регулярных выражений. Единственная проблема, возникшая в процессе разработки --- скобки могут быть несбалансированными, например, находиться в строковых константах. Эти случаи необходимо обрабатывать.

Класс \texttt{todo} реализует алгоритм предварительного упрощения файлов. Очевидно, что для ускорения работы данный алгоритм может быть распареллелен --- каждый файл может обрабатываться отдельно. Экспериментальным путем был выделен следующий набор трансформаций для предварительного упрощения файлов:
\begin{itemize}
	\item упрощение функций и свойств;
	\item трансформации над текстовым представлением программы;
	\item удаление пустых управляющих конструкций;
	\item удаление неиспользуемых импортов.
\end{itemize}


\subsection{Пакет com.stepanov.reduktor.passes.slicer}
Данный пакет содержит в себе классы, реализующие алгоритмы программных срезов, описанные в предыдущем разделе. Пакет содержит класс \texttt{Slicer}, который принимает на вход номер строки с ошибкой и запускает выбранный вид слайсинга. Для получения переменных по номеру строки была написана функция \texttt{getline}, которая обходит дерево разбора в глубину, считая количество переводов строки, в нужный момент останавливается и извлекает имена всех использующихся в этой строке переменных. 

Как было описано ранее, внутрипроцедурный слайсер обходит тело функции снизу вверх и удаляет все то, что не относится к критерию среза. Данный проход имеет несколько особенностей реализации:
\begin{itemize}
	\item если в критерии среза содержится номер строки, указывающей на вызов функции, то в качестве переменных в критерии среза используются аргументы, переданные в функцию;
	\item если известно, в какой функции содержится ошибка, но неизвестно ее точное местоположение, то, ввиду скорости работы слайсера, поочередно производится слайсинг относительное каждой строки этой функции;
	\item для безопасности слайсинга определен четкий набор обрабатываемых видов выражений(унарное, бинарное, вызов функции и т.д.), также отдельно обрабатываются блоки.
\end{itemize}

Слайсер на уровне функций работает по алгоритму, описанному в главе 3 --- строит дерево использований функций, где корнем является функция с ошибкой и удаляет все функции, которые не попали в это дерево. Для реализации построения дерева необходимо соотнести вызов функции с её сигнатурой. Так как при редукции компиляторных ошибок анализ кода часто не может быть проведен, то у нас нет никакой информации о типах аргументов в вызове функции, если они не указаны явно. Для решения этой проблемы была написана функция \texttt{getSignature}, которая считает количество передаваемых аргументов. Таким образом решается данная проблема. Для хранения пар (сигнатура функции-ее узел в дереве) используется словарь. Очевидно, что иногда такой подход будет строить неверные деревья, поэтому перед удалением каждой функции производится проверка корректности удаления. Также стоит отметить, что дерево строится с фильтрацией рекурсивных вызовов.

\section{Реализация менеджера проходов}
В пакете \texttt{reducer} содержится компонент \texttt{TransformationManager}, реализующий управление всеми трансформациями. Данный компонент осуществляет запуск наборов трансформаций для проектов \texttt{doProjectTransformations} и отдельных файлов \texttt{doTransformations}. Порядок трансформаций представлен на рисунке~\ref{img:passOrder}. Трансформации запускаются в цикле до тех пор, пока файл с ошибкой не перестанет меняться. Также данный компонент занимается постобработкой результатов --- сохранением и запуском удалений лишних переводов строк. Вместо удаления лишних переводов строк изначально планировался полный codestyling. Существует проект для исправления стиля кода, называется ktlint, но его применение не дало ожидаемых результатов. После этого была попытка использовать модуль редактирования стиля кода из среды разработки IDEA и компилятора Kotlin, но ввиду сложности и запутанности реализации данного модуля его перенос не привел к успеху. 

\section{Реализация вспомогательных компонентов}
Пакет \texttt{util} содержит вспомогательные компоненты, решающие следующие задачи:
\begin{itemize}
	\item запуск программы и проверка воспроизведения ошибки \texttt{TestChecker};
	\item дерево для хранения объектов любого типа \texttt{DependencyTree};
	\item хранение аргументов, с которым запускается компилятор \texttt{CompilerArgs};
	\item разбор сообщения об ошибке и ее хранение \texttt{Error};
	\item распараллеливание задач любых видов на уровне файлов \texttt{ParralelFileProcessingUtil};
	\item удаление файлов исходного кода из архива с зависимостями \texttt{RemoveSourcesFromJar};
	\item дополнительные функции для редактирования PSI \texttt{Extensions}.
\end{itemize}
Ниже приведено описание наиболее интересных компонентов.

\subsection{Компонент \texttt{CompilatorCrushingTestChecker}}
Так как основным применением разработанного протоипа является редукция программ, приводящих к ошибкам компилятора, был разработан отдельный компонент для запуска программ и проверки воспроизведения ошибок. За это отвечает функция \texttt{checkTest}. В данной функции содержится две доработки для многократного повышения скорости работы прототипа. Первый --- сохранение уже проверенных конфигураций. Для этого используется хеш-таблица, содержащая хэш-код проверенных конфигураций и результат ее проверки. Второй --- проверка синтаксической корректности запускаемого теста, и если тест некорректен, он пропускается. Для данной проверки используется инструментарий компилятора Kotlin: если текст программы некорректен, PSI для нее содержит специальный вид узлов, сингализирующих об этом. 

Для запуска программы используется компонент \texttt{K2JVMCompiler} из компилятора. С помощью компонента \texttt{CompilerArgs} задаются все необходимые аргументы и производится запуск компилятора посредством библиотеки \texttt{java.util.concurrent}. Результат запуска сохраняется в специальную структуру \texttt{MessageCollector}, содержащую всю необходимую инфомрацию об ошибке. Далее происходит разбор ошибки, и сравнение ее с исходной. В том случае, если исходная ошибка не подходит ни под один заданный шаблон, сраниваются текстовые представления ошибок алгоритмом, описанным в главе 3. Для сравнения используется библиотека \texttt{DiffMatchPatch}, после чего считается коэффициент различия файлов и сравнивается с заданным коэффициентом, который подбирается экспериментально. 

\subsection{Компонент \texttt{ParallelFileProcessingUtil}}
Данный компонент реализует параллельный запуск задач на выполнение. Для распараллеливания используется стандартный пакет \texttt{java.util.concurrent}, содержащий все необходимые для этого инструменты. Количество потоков равно количеству процессоров. Для каждого потока создается копия проекта, после обработки новый файл сохраняется в старый проект. В проекте используются два вида параллельных задач: быстрое упрощение и набор трансформаций, описанных в компоненте \texttt{todo}. Быстрое упрощение состоит в попытке замены тел всех функций на вызов специальной функции TODO(). В случае, если все функции не влияют на воспроизведение ошибки, производится удаление их тел, что значительно уменьшает размер обрабатываемого кода. 

\subsection{Компонент \texttt{RemoveSourcesFromJar}}
Для учета всех зависимостей в качестве аргумента компилятору необходимо указывать архив с зависимостями. Данный архив практически всегда содержит и исходный код программы. Это приводит к тому, что при удалении какого-либо компонента программы он берется из архива. Описанная ситуация приводит к невозможности воспроизведения ошибки. Данный компонент занимается удалением всех файлов исходного кода из архива с зависимостями.

\section{Резюме}
В данном разделе были описаны компоненты, реализующие предложенный подход редукции программ на языке Kotlin. Исходный код для некоторых описанных компонентов приведен в приложении.